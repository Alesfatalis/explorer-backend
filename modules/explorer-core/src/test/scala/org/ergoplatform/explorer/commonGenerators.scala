package org.ergoplatform.explorer

import eu.timepit.refined._
import eu.timepit.refined.string.HexStringSpec
import io.circe.Json
import io.estatico.newtype.ops._
import org.ergoplatform.explorer.constraints.Base58Spec
import org.scalacheck.{Arbitrary, Gen}
import scorex.crypto.hash.Blake2b256
import scorex.util.Random
import scorex.util.encode.{Base16, Base58}

object commonGenerators {

  implicit val arbHex: Arbitrary[HexString]   = Arbitrary(hexStringRGen)
  implicit val arbAddr: Arbitrary[Address]    = Arbitrary(addressGen)
  implicit val arbJson: Arbitrary[Json]       = Arbitrary(jsonFieldsGen)
  implicit val arbId: Arbitrary[Id]           = Arbitrary(idGen)
  implicit val arbTxId: Arbitrary[TxId]       = Arbitrary(txIdGen)
  implicit val arbBoxId: Arbitrary[BoxId]     = Arbitrary(boxIdGen)
  implicit val arbAssetId: Arbitrary[TokenId] = Arbitrary(assetIdGen)

  def hexStringGen: Gen[String] =
    Gen
      .nonEmptyListOf(Gen.alphaNumChar)
      .map(_ => Base16.encode(Blake2b256.hash(Random.randomBytes().mkString)))

  def hexStringRGen: Gen[HexString] =
    hexStringGen
      .map(x => refineV[HexStringSpec](x).right.get)
      .map(HexString.apply)

  def addressGen: Gen[Address] =
    Gen
      .nonEmptyListOf(Gen.alphaNumChar)
      .map(x => Base58.encode(Blake2b256.hash(x.mkString)))
      .map(x => refineV[Base58Spec](x).right.get)
      .map(Address.apply)

  def jsonFieldsGen: Gen[Json] =
    Gen.oneOf(
      List(
        Json.obj(
          "0x00" -> Json.fromString("fa209e"),
          "0x01" -> Json.fromString("871b"),
          "0x02" -> Json.fromString("6ac2e1c9")
        ),
        Json.Null
      )
    )

  def idGen: Gen[Id] =
    hexStringGen.map(_.coerce[Id])

  def txIdGen: Gen[TxId] =
    hexStringGen.map(_.coerce[TxId])

  def boxIdGen: Gen[BoxId] =
    hexStringGen.map(_.coerce[BoxId])

  def assetIdGen: Gen[TokenId] =
    hexStringGen.map(_.coerce[TokenId])

  /** Runs a given `test` for a single sample generated by a given `gen`.
    */
  def forSingleInstance[T](gen: Gen[T])(test: T => Any): Any = {
    val numRetries = 1000
    @scala.annotation.tailrec
    def go(retries: Int): Any =
      gen.sample match {
        case Some(sample) =>
          test(sample)
        case None if retries <= numRetries =>
          go(retries + 1)
        case None =>
          throw new Exception(s"Gave up after $numRetries attempts")
      }
    go(0)
  }
}
